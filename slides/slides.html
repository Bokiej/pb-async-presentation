<div class="reveal">
    <div class="slides">
        <section data-background-color="var(--pb-orange-color)">
            <h2>How JavaScript Engine works?</h2>
            <p>Browser JS engine has lot of places like <b>call stack</b>, <b>event loop</b>, <b>callback queue</b> where your code can be processed.</p>
        </section>
        <section>
            <h3 class="pb-title">Visualise how it works</h3>
            <section data-auto-animate>
                <p>The easiest way to understand how JavaScript's call stack, event loop, callback queue interact with each other is to watch video of Philip Roberts (<a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="blank">here</a>) and use his smart tool <a href="http://latentflip.com/loupe/" target="blank">Loupe</a> which visualise this in runtime.</p>
            </section>
        </section>
        <section>
            <h3 class="pb-title">SetTimeout example</h3>
            <section>
                <p><b>Loupe</b> will show in simple example how JS engine works</p>
                <a href="http://latentflip.com/loupe/?code=Cgpjb25zb2xlLmxvZygiU2ltcGxlIGNvZGUgMSIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkFzeW5jIDEiKTsKfSwgNTAwMCk7Cgpjb25zb2xlLmxvZygiU2ltcGxlIGNvZGUgMiIpOw%3D%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="blank">Click here</a>
            </section>
            <section>
                <p>Webapis like <b>setTimeout</b> after has been readed by JS parser lets code to be continued and waits separately until its asynchronous proces is done. Then its callback goes to <b>task queue</b> where wait for <b>event loop</b> to check if <b>call stack</b> is empty and if it is then put it to the bottom of the <b>call stack</b>. Simple right ?</p>
            </section>
        </section>
        <section>
            <h3 class="pb-title">setTimeout on 0s</h3>
            <section>
                <p><b>Loupe</b> example for what happens when we set the same setTimeput for 0s</p>
                <a href="http://latentflip.com/loupe/?code=Cgpjb25zb2xlLmxvZygiU2ltcGxlIGNvZGUgMSIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkFzeW5jIDEiKTsKfSwgMCk7Cgpjb25zb2xlLmxvZygiU2ltcGxlIGNvZGUgMiIpOw%3D%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="blank">Click here</a>
            </section>
            <section>
                <p>Setting setTimeout on 0s looks strange but it makes sense since we forcing async setTimeout to invoke imeddiatly and wait until <b>Call Stack</b> goes empty.</p>
            </section>
        </section>
        <section data-background-color="var(--pb-orange-color)">
            <h2>Promises uses Microtask queue</h2>
            <p class="fst-italic">Microtask Queue is like the Callback Queue, but Microtask Queue has higher priority. All the callback functions coming through Promises and Mutation Observer will go inside the Microtask Queue. For example, in the case of .fetch(), the callback function gets to the Microtask Queue. Promise handling always has higher priority so the JavaScript engine executes all the tasks from Microtask Queue and then moves to the Callback Queue.</p>
            <p class="text-end">
                <a href="https://www.geeksforgeeks.org/what-is-the-difference-between-microtask-queue-and-callback-queue-in-asynchronous-javascript/" target="blank">GeeksForGeeks</a>
            </p>
            <button class="pb-next" type="button" onclick="nextBranch('async-3-1-1')">2 go</button>
        </section>
    </div>
</div>